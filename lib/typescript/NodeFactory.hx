package typescript;

typedef NodeFactory = {
	function createNodeArray<T>(?elements:haxe.ds.ReadOnlyArray<T>, ?hasTrailingComma:Bool):NodeArray<T>;
	function createNumericLiteral(value:ts.AnyOf2<String, Float>, ?numericLiteralFlags:TokenFlags):NumericLiteral;
	function createBigIntLiteral(value:ts.AnyOf2<String, PseudoBigInt>):BigIntLiteral;
	function createStringLiteral(text:String, ?isSingleQuote:Bool):StringLiteral;
	function createStringLiteralFromNode(sourceNode:ts.AnyOf4<Identifier, StringLiteral, NoSubstitutionTemplateLiteral, NumericLiteral>, ?isSingleQuote:Bool):StringLiteral;
	function createRegularExpressionLiteral(text:String):RegularExpressionLiteral;
	function createIdentifier(text:String):Identifier;
	/**
		Create a unique temporary variable.
	**/
	function createTempVariable(recordTempVariable:Null<(node:Identifier) -> Void>):Identifier;
	/**
		Create a unique temporary variable for use in a loop.
	**/
	function createLoopVariable():Identifier;
	/**
		Create a unique name based on the supplied text.
	**/
	function createUniqueName(text:String, ?flags:GeneratedIdentifierFlags):Identifier;
	/**
		Create a unique name generated for a node.
	**/
	function getGeneratedNameForNode(node:Null<Node>):Identifier;
	function createPrivateIdentifier(text:String):PrivateIdentifier;
	@:overload(function(token:Int):ThisExpression { })
	@:overload(function(token:Int):NullLiteral { })
	@:overload(function(token:Int):TrueLiteral { })
	@:overload(function(token:Int):FalseLiteral { })
	@:overload(function<TKind>(token:TKind):PunctuationToken<TKind> { })
	@:overload(function<TKind>(token:TKind):KeywordTypeNode<TKind> { })
	@:overload(function<TKind>(token:TKind):ModifierToken<TKind> { })
	@:overload(function<TKind>(token:TKind):KeywordToken<TKind> { })
	@:overload(function<TKind>(token:TKind):Token<TKind> { })
	function createToken(token:Int):SuperExpression;
	function createSuper():SuperExpression;
	function createThis():ThisExpression;
	function createNull():NullLiteral;
	function createTrue():TrueLiteral;
	function createFalse():FalseLiteral;
	function createModifier<T>(kind:T):ModifierToken<T>;
	function createModifiersFromModifierFlags(flags:ModifierFlags):Array<Modifier>;
	function createQualifiedName(left:EntityName, right:ts.AnyOf2<String, Identifier>):QualifiedName;
	function updateQualifiedName(node:QualifiedName, left:EntityName, right:Identifier):QualifiedName;
	function createComputedPropertyName(expression:Expression):ComputedPropertyName;
	function updateComputedPropertyName(node:ComputedPropertyName, expression:Expression):ComputedPropertyName;
	function createTypeParameterDeclaration(name:ts.AnyOf2<String, Identifier>, ?constraint:TypeNode, ?defaultType:TypeNode):TypeParameterDeclaration;
	function updateTypeParameterDeclaration(node:TypeParameterDeclaration, name:Identifier, constraint:Null<TypeNode>, defaultType:Null<TypeNode>):TypeParameterDeclaration;
	function createParameterDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, dotDotDotToken:Null<DotDotDotToken>, name:ts.AnyOf4<String, Identifier, ObjectBindingPattern, ArrayBindingPattern>, ?questionToken:QuestionToken, ?type:TypeNode, ?initializer:Expression):ParameterDeclaration;
	function updateParameterDeclaration(node:ParameterDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, dotDotDotToken:Null<DotDotDotToken>, name:ts.AnyOf4<String, Identifier, ObjectBindingPattern, ArrayBindingPattern>, questionToken:Null<QuestionToken>, type:Null<TypeNode>, initializer:Null<Expression>):ParameterDeclaration;
	function createDecorator(expression:Expression):Decorator;
	function updateDecorator(node:Decorator, expression:Expression):Decorator;
	function createPropertySignature(modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ts.AnyOf6<String, Identifier, PrivateIdentifier, StringLiteral, NumericLiteral, ComputedPropertyName>, questionToken:Null<QuestionToken>, type:Null<TypeNode>):PropertySignature;
	function updatePropertySignature(node:PropertySignature, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:PropertyName, questionToken:Null<QuestionToken>, type:Null<TypeNode>):PropertySignature;
	function createPropertyDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ts.AnyOf6<String, Identifier, PrivateIdentifier, StringLiteral, NumericLiteral, ComputedPropertyName>, questionOrExclamationToken:Null<ts.AnyOf2<QuestionToken, ExclamationToken>>, type:Null<TypeNode>, initializer:Null<Expression>):PropertyDeclaration;
	function updatePropertyDeclaration(node:PropertyDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ts.AnyOf6<String, Identifier, PrivateIdentifier, StringLiteral, NumericLiteral, ComputedPropertyName>, questionOrExclamationToken:Null<ts.AnyOf2<QuestionToken, ExclamationToken>>, type:Null<TypeNode>, initializer:Null<Expression>):PropertyDeclaration;
	function createMethodSignature(modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ts.AnyOf6<String, Identifier, PrivateIdentifier, StringLiteral, NumericLiteral, ComputedPropertyName>, questionToken:Null<QuestionToken>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>):MethodSignature;
	function updateMethodSignature(node:MethodSignature, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:PropertyName, questionToken:Null<QuestionToken>, typeParameters:Null<NodeArray<TypeParameterDeclaration>>, parameters:NodeArray<ParameterDeclaration>, type:Null<TypeNode>):MethodSignature;
	function createMethodDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, asteriskToken:Null<AsteriskToken>, name:ts.AnyOf6<String, Identifier, PrivateIdentifier, StringLiteral, NumericLiteral, ComputedPropertyName>, questionToken:Null<QuestionToken>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>, body:Null<Block>):MethodDeclaration;
	function updateMethodDeclaration(node:MethodDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, asteriskToken:Null<AsteriskToken>, name:PropertyName, questionToken:Null<QuestionToken>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>, body:Null<Block>):MethodDeclaration;
	function createConstructorDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, body:Null<Block>):ConstructorDeclaration;
	function updateConstructorDeclaration(node:ConstructorDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, body:Null<Block>):ConstructorDeclaration;
	function createGetAccessorDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ts.AnyOf6<String, Identifier, PrivateIdentifier, StringLiteral, NumericLiteral, ComputedPropertyName>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>, body:Null<Block>):GetAccessorDeclaration;
	function updateGetAccessorDeclaration(node:GetAccessorDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:PropertyName, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>, body:Null<Block>):GetAccessorDeclaration;
	function createSetAccessorDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ts.AnyOf6<String, Identifier, PrivateIdentifier, StringLiteral, NumericLiteral, ComputedPropertyName>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, body:Null<Block>):SetAccessorDeclaration;
	function updateSetAccessorDeclaration(node:SetAccessorDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:PropertyName, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, body:Null<Block>):SetAccessorDeclaration;
	function createCallSignature(typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>):CallSignatureDeclaration;
	function updateCallSignature(node:CallSignatureDeclaration, typeParameters:Null<NodeArray<TypeParameterDeclaration>>, parameters:NodeArray<ParameterDeclaration>, type:Null<TypeNode>):CallSignatureDeclaration;
	function createConstructSignature(typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>):ConstructSignatureDeclaration;
	function updateConstructSignature(node:ConstructSignatureDeclaration, typeParameters:Null<NodeArray<TypeParameterDeclaration>>, parameters:NodeArray<ParameterDeclaration>, type:Null<TypeNode>):ConstructSignatureDeclaration;
	function createIndexSignature(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:TypeNode):IndexSignatureDeclaration;
	function updateIndexSignature(node:IndexSignatureDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:TypeNode):IndexSignatureDeclaration;
	function createTemplateLiteralTypeSpan(type:TypeNode, literal:ts.AnyOf2<TemplateMiddle, TemplateTail>):TemplateLiteralTypeSpan;
	function updateTemplateLiteralTypeSpan(node:TemplateLiteralTypeSpan, type:TypeNode, literal:ts.AnyOf2<TemplateMiddle, TemplateTail>):TemplateLiteralTypeSpan;
	function createKeywordTypeNode<TKind>(kind:TKind):KeywordTypeNode<TKind>;
	function createTypePredicateNode(assertsModifier:Null<AssertsKeyword>, parameterName:ts.AnyOf3<String, Identifier, ThisTypeNode>, type:Null<TypeNode>):TypePredicateNode;
	function updateTypePredicateNode(node:TypePredicateNode, assertsModifier:Null<AssertsKeyword>, parameterName:ts.AnyOf2<Identifier, ThisTypeNode>, type:Null<TypeNode>):TypePredicateNode;
	function createTypeReferenceNode(typeName:ts.AnyOf3<String, Identifier, QualifiedName>, ?typeArguments:haxe.ds.ReadOnlyArray<TypeNode>):TypeReferenceNode;
	function updateTypeReferenceNode(node:TypeReferenceNode, typeName:EntityName, typeArguments:Null<NodeArray<TypeNode>>):TypeReferenceNode;
	function createFunctionTypeNode(typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:TypeNode):FunctionTypeNode;
	function updateFunctionTypeNode(node:FunctionTypeNode, typeParameters:Null<NodeArray<TypeParameterDeclaration>>, parameters:NodeArray<ParameterDeclaration>, type:TypeNode):FunctionTypeNode;
	function createConstructorTypeNode(typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:TypeNode):ConstructorTypeNode;
	function updateConstructorTypeNode(node:ConstructorTypeNode, typeParameters:Null<NodeArray<TypeParameterDeclaration>>, parameters:NodeArray<ParameterDeclaration>, type:TypeNode):ConstructorTypeNode;
	function createTypeQueryNode(exprName:EntityName):TypeQueryNode;
	function updateTypeQueryNode(node:TypeQueryNode, exprName:EntityName):TypeQueryNode;
	function createTypeLiteralNode(members:Null<haxe.ds.ReadOnlyArray<TypeElement>>):TypeLiteralNode;
	function updateTypeLiteralNode(node:TypeLiteralNode, members:NodeArray<TypeElement>):TypeLiteralNode;
	function createArrayTypeNode(elementType:TypeNode):ArrayTypeNode;
	function updateArrayTypeNode(node:ArrayTypeNode, elementType:TypeNode):ArrayTypeNode;
	function createTupleTypeNode(elements:haxe.ds.ReadOnlyArray<ts.AnyOf2<TypeNode, NamedTupleMember>>):TupleTypeNode;
	function updateTupleTypeNode(node:TupleTypeNode, elements:haxe.ds.ReadOnlyArray<ts.AnyOf2<TypeNode, NamedTupleMember>>):TupleTypeNode;
	function createNamedTupleMember(dotDotDotToken:Null<DotDotDotToken>, name:Identifier, questionToken:Null<QuestionToken>, type:TypeNode):NamedTupleMember;
	function updateNamedTupleMember(node:NamedTupleMember, dotDotDotToken:Null<DotDotDotToken>, name:Identifier, questionToken:Null<QuestionToken>, type:TypeNode):NamedTupleMember;
	function createOptionalTypeNode(type:TypeNode):OptionalTypeNode;
	function updateOptionalTypeNode(node:OptionalTypeNode, type:TypeNode):OptionalTypeNode;
	function createRestTypeNode(type:TypeNode):RestTypeNode;
	function updateRestTypeNode(node:RestTypeNode, type:TypeNode):RestTypeNode;
	function createUnionTypeNode(types:haxe.ds.ReadOnlyArray<TypeNode>):UnionTypeNode;
	function updateUnionTypeNode(node:UnionTypeNode, types:NodeArray<TypeNode>):UnionTypeNode;
	function createIntersectionTypeNode(types:haxe.ds.ReadOnlyArray<TypeNode>):IntersectionTypeNode;
	function updateIntersectionTypeNode(node:IntersectionTypeNode, types:NodeArray<TypeNode>):IntersectionTypeNode;
	function createConditionalTypeNode(checkType:TypeNode, extendsType:TypeNode, trueType:TypeNode, falseType:TypeNode):ConditionalTypeNode;
	function updateConditionalTypeNode(node:ConditionalTypeNode, checkType:TypeNode, extendsType:TypeNode, trueType:TypeNode, falseType:TypeNode):ConditionalTypeNode;
	function createInferTypeNode(typeParameter:TypeParameterDeclaration):InferTypeNode;
	function updateInferTypeNode(node:InferTypeNode, typeParameter:TypeParameterDeclaration):InferTypeNode;
	function createImportTypeNode(argument:TypeNode, ?qualifier:EntityName, ?typeArguments:haxe.ds.ReadOnlyArray<TypeNode>, ?isTypeOf:Bool):ImportTypeNode;
	function updateImportTypeNode(node:ImportTypeNode, argument:TypeNode, qualifier:Null<EntityName>, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, ?isTypeOf:Bool):ImportTypeNode;
	function createParenthesizedType(type:TypeNode):ParenthesizedTypeNode;
	function updateParenthesizedType(node:ParenthesizedTypeNode, type:TypeNode):ParenthesizedTypeNode;
	function createThisTypeNode():ThisTypeNode;
	function createTypeOperatorNode(operator_:Int, type:TypeNode):TypeOperatorNode;
	function updateTypeOperatorNode(node:TypeOperatorNode, type:TypeNode):TypeOperatorNode;
	function createIndexedAccessTypeNode(objectType:TypeNode, indexType:TypeNode):IndexedAccessTypeNode;
	function updateIndexedAccessTypeNode(node:IndexedAccessTypeNode, objectType:TypeNode, indexType:TypeNode):IndexedAccessTypeNode;
	function createMappedTypeNode(readonlyToken:Null<ts.AnyOf3<ReadonlyKeyword, PlusToken, MinusToken>>, typeParameter:TypeParameterDeclaration, nameType:Null<TypeNode>, questionToken:Null<ts.AnyOf3<QuestionToken, PlusToken, MinusToken>>, type:Null<TypeNode>):MappedTypeNode;
	function updateMappedTypeNode(node:MappedTypeNode, readonlyToken:Null<ts.AnyOf3<ReadonlyKeyword, PlusToken, MinusToken>>, typeParameter:TypeParameterDeclaration, nameType:Null<TypeNode>, questionToken:Null<ts.AnyOf3<QuestionToken, PlusToken, MinusToken>>, type:Null<TypeNode>):MappedTypeNode;
	function createLiteralTypeNode(literal:ts.AnyOf5<LiteralExpression, NullLiteral, TrueLiteral, FalseLiteral, PrefixUnaryExpression>):LiteralTypeNode;
	function updateLiteralTypeNode(node:LiteralTypeNode, literal:ts.AnyOf5<LiteralExpression, NullLiteral, TrueLiteral, FalseLiteral, PrefixUnaryExpression>):LiteralTypeNode;
	function createTemplateLiteralType(head:TemplateHead, templateSpans:haxe.ds.ReadOnlyArray<TemplateLiteralTypeSpan>):TemplateLiteralTypeNode;
	function updateTemplateLiteralType(node:TemplateLiteralTypeNode, head:TemplateHead, templateSpans:haxe.ds.ReadOnlyArray<TemplateLiteralTypeSpan>):TemplateLiteralTypeNode;
	function createObjectBindingPattern(elements:haxe.ds.ReadOnlyArray<BindingElement>):ObjectBindingPattern;
	function updateObjectBindingPattern(node:ObjectBindingPattern, elements:haxe.ds.ReadOnlyArray<BindingElement>):ObjectBindingPattern;
	function createArrayBindingPattern(elements:haxe.ds.ReadOnlyArray<ArrayBindingElement>):ArrayBindingPattern;
	function updateArrayBindingPattern(node:ArrayBindingPattern, elements:haxe.ds.ReadOnlyArray<ArrayBindingElement>):ArrayBindingPattern;
	function createBindingElement(dotDotDotToken:Null<DotDotDotToken>, propertyName:Null<ts.AnyOf6<String, Identifier, PrivateIdentifier, StringLiteral, NumericLiteral, ComputedPropertyName>>, name:ts.AnyOf4<String, Identifier, ObjectBindingPattern, ArrayBindingPattern>, ?initializer:Expression):BindingElement;
	function updateBindingElement(node:BindingElement, dotDotDotToken:Null<DotDotDotToken>, propertyName:Null<PropertyName>, name:BindingName, initializer:Null<Expression>):BindingElement;
	function createArrayLiteralExpression(?elements:haxe.ds.ReadOnlyArray<Expression>, ?multiLine:Bool):ArrayLiteralExpression;
	function updateArrayLiteralExpression(node:ArrayLiteralExpression, elements:haxe.ds.ReadOnlyArray<Expression>):ArrayLiteralExpression;
	function createObjectLiteralExpression(?properties:haxe.ds.ReadOnlyArray<ObjectLiteralElementLike>, ?multiLine:Bool):ObjectLiteralExpression;
	function updateObjectLiteralExpression(node:ObjectLiteralExpression, properties:haxe.ds.ReadOnlyArray<ObjectLiteralElementLike>):ObjectLiteralExpression;
	function createPropertyAccessExpression(expression:Expression, name:ts.AnyOf3<String, Identifier, PrivateIdentifier>):PropertyAccessExpression;
	function updatePropertyAccessExpression(node:PropertyAccessExpression, expression:Expression, name:ts.AnyOf2<Identifier, PrivateIdentifier>):PropertyAccessExpression;
	function createPropertyAccessChain(expression:Expression, questionDotToken:Null<QuestionDotToken>, name:ts.AnyOf3<String, Identifier, PrivateIdentifier>):PropertyAccessChain;
	function updatePropertyAccessChain(node:PropertyAccessChain, expression:Expression, questionDotToken:Null<QuestionDotToken>, name:ts.AnyOf2<Identifier, PrivateIdentifier>):PropertyAccessChain;
	function createElementAccessExpression(expression:Expression, index:ts.AnyOf2<Float, Expression>):ElementAccessExpression;
	function updateElementAccessExpression(node:ElementAccessExpression, expression:Expression, argumentExpression:Expression):ElementAccessExpression;
	function createElementAccessChain(expression:Expression, questionDotToken:Null<QuestionDotToken>, index:ts.AnyOf2<Float, Expression>):ElementAccessChain;
	function updateElementAccessChain(node:ElementAccessChain, expression:Expression, questionDotToken:Null<QuestionDotToken>, argumentExpression:Expression):ElementAccessChain;
	function createCallExpression(expression:Expression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, argumentsArray:Null<haxe.ds.ReadOnlyArray<Expression>>):CallExpression;
	function updateCallExpression(node:CallExpression, expression:Expression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, argumentsArray:haxe.ds.ReadOnlyArray<Expression>):CallExpression;
	function createCallChain(expression:Expression, questionDotToken:Null<QuestionDotToken>, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, argumentsArray:Null<haxe.ds.ReadOnlyArray<Expression>>):CallChain;
	function updateCallChain(node:CallChain, expression:Expression, questionDotToken:Null<QuestionDotToken>, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, argumentsArray:haxe.ds.ReadOnlyArray<Expression>):CallChain;
	function createNewExpression(expression:Expression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, argumentsArray:Null<haxe.ds.ReadOnlyArray<Expression>>):NewExpression;
	function updateNewExpression(node:NewExpression, expression:Expression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, argumentsArray:Null<haxe.ds.ReadOnlyArray<Expression>>):NewExpression;
	function createTaggedTemplateExpression(tag:Expression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, template:TemplateLiteral):TaggedTemplateExpression;
	function updateTaggedTemplateExpression(node:TaggedTemplateExpression, tag:Expression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, template:TemplateLiteral):TaggedTemplateExpression;
	function createTypeAssertion(type:TypeNode, expression:Expression):TypeAssertion;
	function updateTypeAssertion(node:TypeAssertion, type:TypeNode, expression:Expression):TypeAssertion;
	function createParenthesizedExpression(expression:Expression):ParenthesizedExpression;
	function updateParenthesizedExpression(node:ParenthesizedExpression, expression:Expression):ParenthesizedExpression;
	function createFunctionExpression(modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, asteriskToken:Null<AsteriskToken>, name:Null<ts.AnyOf2<String, Identifier>>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:Null<haxe.ds.ReadOnlyArray<ParameterDeclaration>>, type:Null<TypeNode>, body:Block):FunctionExpression;
	function updateFunctionExpression(node:FunctionExpression, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, asteriskToken:Null<AsteriskToken>, name:Null<Identifier>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>, body:Block):FunctionExpression;
	function createArrowFunction(modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>, equalsGreaterThanToken:Null<EqualsGreaterThanToken>, body:ConciseBody):ArrowFunction;
	function updateArrowFunction(node:ArrowFunction, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>, equalsGreaterThanToken:EqualsGreaterThanToken, body:ConciseBody):ArrowFunction;
	function createDeleteExpression(expression:Expression):DeleteExpression;
	function updateDeleteExpression(node:DeleteExpression, expression:Expression):DeleteExpression;
	function createTypeOfExpression(expression:Expression):TypeOfExpression;
	function updateTypeOfExpression(node:TypeOfExpression, expression:Expression):TypeOfExpression;
	function createVoidExpression(expression:Expression):VoidExpression;
	function updateVoidExpression(node:VoidExpression, expression:Expression):VoidExpression;
	function createAwaitExpression(expression:Expression):AwaitExpression;
	function updateAwaitExpression(node:AwaitExpression, expression:Expression):AwaitExpression;
	function createPrefixUnaryExpression(operator_:PrefixUnaryOperator, operand:Expression):PrefixUnaryExpression;
	function updatePrefixUnaryExpression(node:PrefixUnaryExpression, operand:Expression):PrefixUnaryExpression;
	function createPostfixUnaryExpression(operand:Expression, operator_:PostfixUnaryOperator):PostfixUnaryExpression;
	function updatePostfixUnaryExpression(node:PostfixUnaryExpression, operand:Expression):PostfixUnaryExpression;
	function createBinaryExpression(left:Expression, operator_:ts.AnyOf2<Int, BinaryOperatorToken>, right:Expression):BinaryExpression;
	function updateBinaryExpression(node:BinaryExpression, left:Expression, operator_:ts.AnyOf2<Int, BinaryOperatorToken>, right:Expression):BinaryExpression;
	function createConditionalExpression(condition:Expression, questionToken:Null<QuestionToken>, whenTrue:Expression, colonToken:Null<ColonToken>, whenFalse:Expression):ConditionalExpression;
	function updateConditionalExpression(node:ConditionalExpression, condition:Expression, questionToken:QuestionToken, whenTrue:Expression, colonToken:ColonToken, whenFalse:Expression):ConditionalExpression;
	function createTemplateExpression(head:TemplateHead, templateSpans:haxe.ds.ReadOnlyArray<TemplateSpan>):TemplateExpression;
	function updateTemplateExpression(node:TemplateExpression, head:TemplateHead, templateSpans:haxe.ds.ReadOnlyArray<TemplateSpan>):TemplateExpression;
	@:overload(function(text:Null<String>, rawText:String, ?templateFlags:TokenFlags):TemplateHead { })
	function createTemplateHead(text:String, ?rawText:String, ?templateFlags:TokenFlags):TemplateHead;
	@:overload(function(text:Null<String>, rawText:String, ?templateFlags:TokenFlags):TemplateMiddle { })
	function createTemplateMiddle(text:String, ?rawText:String, ?templateFlags:TokenFlags):TemplateMiddle;
	@:overload(function(text:Null<String>, rawText:String, ?templateFlags:TokenFlags):TemplateTail { })
	function createTemplateTail(text:String, ?rawText:String, ?templateFlags:TokenFlags):TemplateTail;
	@:overload(function(text:Null<String>, rawText:String):NoSubstitutionTemplateLiteral { })
	function createNoSubstitutionTemplateLiteral(text:String, ?rawText:String):NoSubstitutionTemplateLiteral;
	@:overload(function(asteriskToken:Null<Any>, expression:Null<Expression>):YieldExpression { })
	function createYieldExpression(asteriskToken:AsteriskToken, expression:Expression):YieldExpression;
	function updateYieldExpression(node:YieldExpression, asteriskToken:Null<AsteriskToken>, expression:Null<Expression>):YieldExpression;
	function createSpreadElement(expression:Expression):SpreadElement;
	function updateSpreadElement(node:SpreadElement, expression:Expression):SpreadElement;
	function createClassExpression(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:Null<ts.AnyOf2<String, Identifier>>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, heritageClauses:Null<haxe.ds.ReadOnlyArray<HeritageClause>>, members:haxe.ds.ReadOnlyArray<ClassElement>):ClassExpression;
	function updateClassExpression(node:ClassExpression, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:Null<Identifier>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, heritageClauses:Null<haxe.ds.ReadOnlyArray<HeritageClause>>, members:haxe.ds.ReadOnlyArray<ClassElement>):ClassExpression;
	function createOmittedExpression():OmittedExpression;
	function createExpressionWithTypeArguments(expression:Expression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>):ExpressionWithTypeArguments;
	function updateExpressionWithTypeArguments(node:ExpressionWithTypeArguments, expression:Expression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>):ExpressionWithTypeArguments;
	function createAsExpression(expression:Expression, type:TypeNode):AsExpression;
	function updateAsExpression(node:AsExpression, expression:Expression, type:TypeNode):AsExpression;
	function createNonNullExpression(expression:Expression):NonNullExpression;
	function updateNonNullExpression(node:NonNullExpression, expression:Expression):NonNullExpression;
	function createNonNullChain(expression:Expression):NonNullChain;
	function updateNonNullChain(node:NonNullChain, expression:Expression):NonNullChain;
	function createMetaProperty(keywordToken:Int, name:Identifier):MetaProperty;
	function updateMetaProperty(node:MetaProperty, name:Identifier):MetaProperty;
	function createTemplateSpan(expression:Expression, literal:ts.AnyOf2<TemplateMiddle, TemplateTail>):TemplateSpan;
	function updateTemplateSpan(node:TemplateSpan, expression:Expression, literal:ts.AnyOf2<TemplateMiddle, TemplateTail>):TemplateSpan;
	function createSemicolonClassElement():SemicolonClassElement;
	function createBlock(statements:haxe.ds.ReadOnlyArray<Statement>, ?multiLine:Bool):Block;
	function updateBlock(node:Block, statements:haxe.ds.ReadOnlyArray<Statement>):Block;
	function createVariableStatement(modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, declarationList:ts.AnyOf2<VariableDeclarationList, haxe.ds.ReadOnlyArray<VariableDeclaration>>):VariableStatement;
	function updateVariableStatement(node:VariableStatement, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, declarationList:VariableDeclarationList):VariableStatement;
	function createEmptyStatement():EmptyStatement;
	function createExpressionStatement(expression:Expression):ExpressionStatement;
	function updateExpressionStatement(node:ExpressionStatement, expression:Expression):ExpressionStatement;
	function createIfStatement(expression:Expression, thenStatement:Statement, ?elseStatement:Statement):IfStatement;
	function updateIfStatement(node:IfStatement, expression:Expression, thenStatement:Statement, elseStatement:Null<Statement>):IfStatement;
	function createDoStatement(statement:Statement, expression:Expression):DoStatement;
	function updateDoStatement(node:DoStatement, statement:Statement, expression:Expression):DoStatement;
	function createWhileStatement(expression:Expression, statement:Statement):WhileStatement;
	function updateWhileStatement(node:WhileStatement, expression:Expression, statement:Statement):WhileStatement;
	function createForStatement(initializer:Null<ts.AnyOf2<Expression, VariableDeclarationList>>, condition:Null<Expression>, incrementor:Null<Expression>, statement:Statement):ForStatement;
	function updateForStatement(node:ForStatement, initializer:Null<ts.AnyOf2<Expression, VariableDeclarationList>>, condition:Null<Expression>, incrementor:Null<Expression>, statement:Statement):ForStatement;
	function createForInStatement(initializer:ts.AnyOf2<Expression, VariableDeclarationList>, expression:Expression, statement:Statement):ForInStatement;
	function updateForInStatement(node:ForInStatement, initializer:ts.AnyOf2<Expression, VariableDeclarationList>, expression:Expression, statement:Statement):ForInStatement;
	function createForOfStatement(awaitModifier:Null<AwaitKeyword>, initializer:ts.AnyOf2<Expression, VariableDeclarationList>, expression:Expression, statement:Statement):ForOfStatement;
	function updateForOfStatement(node:ForOfStatement, awaitModifier:Null<AwaitKeyword>, initializer:ts.AnyOf2<Expression, VariableDeclarationList>, expression:Expression, statement:Statement):ForOfStatement;
	function createContinueStatement(?label:ts.AnyOf2<String, Identifier>):ContinueStatement;
	function updateContinueStatement(node:ContinueStatement, label:Null<Identifier>):ContinueStatement;
	function createBreakStatement(?label:ts.AnyOf2<String, Identifier>):BreakStatement;
	function updateBreakStatement(node:BreakStatement, label:Null<Identifier>):BreakStatement;
	function createReturnStatement(?expression:Expression):ReturnStatement;
	function updateReturnStatement(node:ReturnStatement, expression:Null<Expression>):ReturnStatement;
	function createWithStatement(expression:Expression, statement:Statement):WithStatement;
	function updateWithStatement(node:WithStatement, expression:Expression, statement:Statement):WithStatement;
	function createSwitchStatement(expression:Expression, caseBlock:CaseBlock):SwitchStatement;
	function updateSwitchStatement(node:SwitchStatement, expression:Expression, caseBlock:CaseBlock):SwitchStatement;
	function createLabeledStatement(label:ts.AnyOf2<String, Identifier>, statement:Statement):LabeledStatement;
	function updateLabeledStatement(node:LabeledStatement, label:Identifier, statement:Statement):LabeledStatement;
	function createThrowStatement(expression:Expression):ThrowStatement;
	function updateThrowStatement(node:ThrowStatement, expression:Expression):ThrowStatement;
	function createTryStatement(tryBlock:Block, catchClause:Null<CatchClause>, finallyBlock:Null<Block>):TryStatement;
	function updateTryStatement(node:TryStatement, tryBlock:Block, catchClause:Null<CatchClause>, finallyBlock:Null<Block>):TryStatement;
	function createDebuggerStatement():DebuggerStatement;
	function createVariableDeclaration(name:ts.AnyOf4<String, Identifier, ObjectBindingPattern, ArrayBindingPattern>, ?exclamationToken:ExclamationToken, ?type:TypeNode, ?initializer:Expression):VariableDeclaration;
	function updateVariableDeclaration(node:VariableDeclaration, name:BindingName, exclamationToken:Null<ExclamationToken>, type:Null<TypeNode>, initializer:Null<Expression>):VariableDeclaration;
	function createVariableDeclarationList(declarations:haxe.ds.ReadOnlyArray<VariableDeclaration>, ?flags:NodeFlags):VariableDeclarationList;
	function updateVariableDeclarationList(node:VariableDeclarationList, declarations:haxe.ds.ReadOnlyArray<VariableDeclaration>):VariableDeclarationList;
	function createFunctionDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, asteriskToken:Null<AsteriskToken>, name:Null<ts.AnyOf2<String, Identifier>>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>, body:Null<Block>):FunctionDeclaration;
	function updateFunctionDeclaration(node:FunctionDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, asteriskToken:Null<AsteriskToken>, name:Null<Identifier>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>, body:Null<Block>):FunctionDeclaration;
	function createClassDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:Null<ts.AnyOf2<String, Identifier>>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, heritageClauses:Null<haxe.ds.ReadOnlyArray<HeritageClause>>, members:haxe.ds.ReadOnlyArray<ClassElement>):ClassDeclaration;
	function updateClassDeclaration(node:ClassDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:Null<Identifier>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, heritageClauses:Null<haxe.ds.ReadOnlyArray<HeritageClause>>, members:haxe.ds.ReadOnlyArray<ClassElement>):ClassDeclaration;
	function createInterfaceDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ts.AnyOf2<String, Identifier>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, heritageClauses:Null<haxe.ds.ReadOnlyArray<HeritageClause>>, members:haxe.ds.ReadOnlyArray<TypeElement>):InterfaceDeclaration;
	function updateInterfaceDeclaration(node:InterfaceDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:Identifier, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, heritageClauses:Null<haxe.ds.ReadOnlyArray<HeritageClause>>, members:haxe.ds.ReadOnlyArray<TypeElement>):InterfaceDeclaration;
	function createTypeAliasDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ts.AnyOf2<String, Identifier>, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, type:TypeNode):TypeAliasDeclaration;
	function updateTypeAliasDeclaration(node:TypeAliasDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:Identifier, typeParameters:Null<haxe.ds.ReadOnlyArray<TypeParameterDeclaration>>, type:TypeNode):TypeAliasDeclaration;
	function createEnumDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ts.AnyOf2<String, Identifier>, members:haxe.ds.ReadOnlyArray<EnumMember>):EnumDeclaration;
	function updateEnumDeclaration(node:EnumDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:Identifier, members:haxe.ds.ReadOnlyArray<EnumMember>):EnumDeclaration;
	function createModuleDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ModuleName, body:Null<ts.AnyOf4<Identifier, ModuleBlock, NamespaceDeclaration, JSDocNamespaceDeclaration>>, ?flags:NodeFlags):ModuleDeclaration;
	function updateModuleDeclaration(node:ModuleDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ModuleName, body:Null<ts.AnyOf4<Identifier, ModuleBlock, NamespaceDeclaration, JSDocNamespaceDeclaration>>):ModuleDeclaration;
	function createModuleBlock(statements:haxe.ds.ReadOnlyArray<Statement>):ModuleBlock;
	function updateModuleBlock(node:ModuleBlock, statements:haxe.ds.ReadOnlyArray<Statement>):ModuleBlock;
	function createCaseBlock(clauses:haxe.ds.ReadOnlyArray<CaseOrDefaultClause>):CaseBlock;
	function updateCaseBlock(node:CaseBlock, clauses:haxe.ds.ReadOnlyArray<CaseOrDefaultClause>):CaseBlock;
	function createNamespaceExportDeclaration(name:ts.AnyOf2<String, Identifier>):NamespaceExportDeclaration;
	function updateNamespaceExportDeclaration(node:NamespaceExportDeclaration, name:Identifier):NamespaceExportDeclaration;
	function createImportEqualsDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:ts.AnyOf2<String, Identifier>, moduleReference:ModuleReference):ImportEqualsDeclaration;
	function updateImportEqualsDeclaration(node:ImportEqualsDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, name:Identifier, moduleReference:ModuleReference):ImportEqualsDeclaration;
	function createImportDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, importClause:Null<ImportClause>, moduleSpecifier:Expression):ImportDeclaration;
	function updateImportDeclaration(node:ImportDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, importClause:Null<ImportClause>, moduleSpecifier:Expression):ImportDeclaration;
	function createImportClause(isTypeOnly:Bool, name:Null<Identifier>, namedBindings:Null<NamedImportBindings>):ImportClause;
	function updateImportClause(node:ImportClause, isTypeOnly:Bool, name:Null<Identifier>, namedBindings:Null<NamedImportBindings>):ImportClause;
	function createNamespaceImport(name:Identifier):NamespaceImport;
	function updateNamespaceImport(node:NamespaceImport, name:Identifier):NamespaceImport;
	function createNamespaceExport(name:Identifier):NamespaceExport;
	function updateNamespaceExport(node:NamespaceExport, name:Identifier):NamespaceExport;
	function createNamedImports(elements:haxe.ds.ReadOnlyArray<ImportSpecifier>):NamedImports;
	function updateNamedImports(node:NamedImports, elements:haxe.ds.ReadOnlyArray<ImportSpecifier>):NamedImports;
	function createImportSpecifier(propertyName:Null<Identifier>, name:Identifier):ImportSpecifier;
	function updateImportSpecifier(node:ImportSpecifier, propertyName:Null<Identifier>, name:Identifier):ImportSpecifier;
	function createExportAssignment(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, isExportEquals:Null<Bool>, expression:Expression):ExportAssignment;
	function updateExportAssignment(node:ExportAssignment, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, expression:Expression):ExportAssignment;
	function createExportDeclaration(decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, isTypeOnly:Bool, exportClause:Null<NamedExportBindings>, ?moduleSpecifier:Expression):ExportDeclaration;
	function updateExportDeclaration(node:ExportDeclaration, decorators:Null<haxe.ds.ReadOnlyArray<Decorator>>, modifiers:Null<haxe.ds.ReadOnlyArray<Modifier>>, isTypeOnly:Bool, exportClause:Null<NamedExportBindings>, moduleSpecifier:Null<Expression>):ExportDeclaration;
	function createNamedExports(elements:haxe.ds.ReadOnlyArray<ExportSpecifier>):NamedExports;
	function updateNamedExports(node:NamedExports, elements:haxe.ds.ReadOnlyArray<ExportSpecifier>):NamedExports;
	function createExportSpecifier(propertyName:Null<ts.AnyOf2<String, Identifier>>, name:ts.AnyOf2<String, Identifier>):ExportSpecifier;
	function updateExportSpecifier(node:ExportSpecifier, propertyName:Null<Identifier>, name:Identifier):ExportSpecifier;
	function createExternalModuleReference(expression:Expression):ExternalModuleReference;
	function updateExternalModuleReference(node:ExternalModuleReference, expression:Expression):ExternalModuleReference;
	function createJSDocAllType():JSDocAllType;
	function createJSDocUnknownType():JSDocUnknownType;
	function createJSDocNonNullableType(type:TypeNode):JSDocNonNullableType;
	function updateJSDocNonNullableType(node:JSDocNonNullableType, type:TypeNode):JSDocNonNullableType;
	function createJSDocNullableType(type:TypeNode):JSDocNullableType;
	function updateJSDocNullableType(node:JSDocNullableType, type:TypeNode):JSDocNullableType;
	function createJSDocOptionalType(type:TypeNode):JSDocOptionalType;
	function updateJSDocOptionalType(node:JSDocOptionalType, type:TypeNode):JSDocOptionalType;
	function createJSDocFunctionType(parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>):JSDocFunctionType;
	function updateJSDocFunctionType(node:JSDocFunctionType, parameters:haxe.ds.ReadOnlyArray<ParameterDeclaration>, type:Null<TypeNode>):JSDocFunctionType;
	function createJSDocVariadicType(type:TypeNode):JSDocVariadicType;
	function updateJSDocVariadicType(node:JSDocVariadicType, type:TypeNode):JSDocVariadicType;
	function createJSDocNamepathType(type:TypeNode):JSDocNamepathType;
	function updateJSDocNamepathType(node:JSDocNamepathType, type:TypeNode):JSDocNamepathType;
	function createJSDocTypeExpression(type:TypeNode):JSDocTypeExpression;
	function updateJSDocTypeExpression(node:JSDocTypeExpression, type:TypeNode):JSDocTypeExpression;
	function createJSDocNameReference(name:EntityName):JSDocNameReference;
	function updateJSDocNameReference(node:JSDocNameReference, name:EntityName):JSDocNameReference;
	function createJSDocTypeLiteral(?jsDocPropertyTags:haxe.ds.ReadOnlyArray<JSDocPropertyLikeTag>, ?isArrayType:Bool):JSDocTypeLiteral;
	function updateJSDocTypeLiteral(node:JSDocTypeLiteral, jsDocPropertyTags:Null<haxe.ds.ReadOnlyArray<JSDocPropertyLikeTag>>, isArrayType:Null<Bool>):JSDocTypeLiteral;
	function createJSDocSignature(typeParameters:Null<haxe.ds.ReadOnlyArray<JSDocTemplateTag>>, parameters:haxe.ds.ReadOnlyArray<JSDocParameterTag>, ?type:JSDocReturnTag):JSDocSignature;
	function updateJSDocSignature(node:JSDocSignature, typeParameters:Null<haxe.ds.ReadOnlyArray<JSDocTemplateTag>>, parameters:haxe.ds.ReadOnlyArray<JSDocParameterTag>, type:Null<JSDocReturnTag>):JSDocSignature;
	function createJSDocTemplateTag(tagName:Null<Identifier>, constraint:Null<JSDocTypeExpression>, typeParameters:haxe.ds.ReadOnlyArray<TypeParameterDeclaration>, ?comment:String):JSDocTemplateTag;
	function updateJSDocTemplateTag(node:JSDocTemplateTag, tagName:Null<Identifier>, constraint:Null<JSDocTypeExpression>, typeParameters:haxe.ds.ReadOnlyArray<TypeParameterDeclaration>, comment:Null<String>):JSDocTemplateTag;
	function createJSDocTypedefTag(tagName:Null<Identifier>, ?typeExpression:ts.AnyOf2<JSDocTypeExpression, JSDocTypeLiteral>, ?fullName:ts.AnyOf2<Identifier, JSDocNamespaceDeclaration>, ?comment:String):JSDocTypedefTag;
	function updateJSDocTypedefTag(node:JSDocTypedefTag, tagName:Null<Identifier>, typeExpression:Null<ts.AnyOf2<JSDocTypeExpression, JSDocTypeLiteral>>, fullName:Null<ts.AnyOf2<Identifier, JSDocNamespaceDeclaration>>, comment:Null<String>):JSDocTypedefTag;
	function createJSDocParameterTag(tagName:Null<Identifier>, name:EntityName, isBracketed:Bool, ?typeExpression:JSDocTypeExpression, ?isNameFirst:Bool, ?comment:String):JSDocParameterTag;
	function updateJSDocParameterTag(node:JSDocParameterTag, tagName:Null<Identifier>, name:EntityName, isBracketed:Bool, typeExpression:Null<JSDocTypeExpression>, isNameFirst:Bool, comment:Null<String>):JSDocParameterTag;
	function createJSDocPropertyTag(tagName:Null<Identifier>, name:EntityName, isBracketed:Bool, ?typeExpression:JSDocTypeExpression, ?isNameFirst:Bool, ?comment:String):JSDocPropertyTag;
	function updateJSDocPropertyTag(node:JSDocPropertyTag, tagName:Null<Identifier>, name:EntityName, isBracketed:Bool, typeExpression:Null<JSDocTypeExpression>, isNameFirst:Bool, comment:Null<String>):JSDocPropertyTag;
	function createJSDocTypeTag(tagName:Null<Identifier>, typeExpression:JSDocTypeExpression, ?comment:String):JSDocTypeTag;
	function updateJSDocTypeTag(node:JSDocTypeTag, tagName:Null<Identifier>, typeExpression:JSDocTypeExpression, comment:Null<String>):JSDocTypeTag;
	function createJSDocSeeTag(tagName:Null<Identifier>, nameExpression:Null<JSDocNameReference>, ?comment:String):JSDocSeeTag;
	function updateJSDocSeeTag(node:JSDocSeeTag, tagName:Null<Identifier>, nameExpression:Null<JSDocNameReference>, ?comment:String):JSDocSeeTag;
	function createJSDocReturnTag(tagName:Null<Identifier>, ?typeExpression:JSDocTypeExpression, ?comment:String):JSDocReturnTag;
	function updateJSDocReturnTag(node:JSDocReturnTag, tagName:Null<Identifier>, typeExpression:Null<JSDocTypeExpression>, comment:Null<String>):JSDocReturnTag;
	function createJSDocThisTag(tagName:Null<Identifier>, typeExpression:JSDocTypeExpression, ?comment:String):JSDocThisTag;
	function updateJSDocThisTag(node:JSDocThisTag, tagName:Null<Identifier>, typeExpression:Null<JSDocTypeExpression>, comment:Null<String>):JSDocThisTag;
	function createJSDocEnumTag(tagName:Null<Identifier>, typeExpression:JSDocTypeExpression, ?comment:String):JSDocEnumTag;
	function updateJSDocEnumTag(node:JSDocEnumTag, tagName:Null<Identifier>, typeExpression:JSDocTypeExpression, comment:Null<String>):JSDocEnumTag;
	function createJSDocCallbackTag(tagName:Null<Identifier>, typeExpression:JSDocSignature, ?fullName:ts.AnyOf2<Identifier, JSDocNamespaceDeclaration>, ?comment:String):JSDocCallbackTag;
	function updateJSDocCallbackTag(node:JSDocCallbackTag, tagName:Null<Identifier>, typeExpression:JSDocSignature, fullName:Null<ts.AnyOf2<Identifier, JSDocNamespaceDeclaration>>, comment:Null<String>):JSDocCallbackTag;
	function createJSDocAugmentsTag(tagName:Null<Identifier>, className:Dynamic, ?comment:String):JSDocAugmentsTag;
	function updateJSDocAugmentsTag(node:JSDocAugmentsTag, tagName:Null<Identifier>, className:Dynamic, comment:Null<String>):JSDocAugmentsTag;
	function createJSDocImplementsTag(tagName:Null<Identifier>, className:Dynamic, ?comment:String):JSDocImplementsTag;
	function updateJSDocImplementsTag(node:JSDocImplementsTag, tagName:Null<Identifier>, className:Dynamic, comment:Null<String>):JSDocImplementsTag;
	function createJSDocAuthorTag(tagName:Null<Identifier>, ?comment:String):JSDocAuthorTag;
	function updateJSDocAuthorTag(node:JSDocAuthorTag, tagName:Null<Identifier>, comment:Null<String>):JSDocAuthorTag;
	function createJSDocClassTag(tagName:Null<Identifier>, ?comment:String):JSDocClassTag;
	function updateJSDocClassTag(node:JSDocClassTag, tagName:Null<Identifier>, comment:Null<String>):JSDocClassTag;
	function createJSDocPublicTag(tagName:Null<Identifier>, ?comment:String):JSDocPublicTag;
	function updateJSDocPublicTag(node:JSDocPublicTag, tagName:Null<Identifier>, comment:Null<String>):JSDocPublicTag;
	function createJSDocPrivateTag(tagName:Null<Identifier>, ?comment:String):JSDocPrivateTag;
	function updateJSDocPrivateTag(node:JSDocPrivateTag, tagName:Null<Identifier>, comment:Null<String>):JSDocPrivateTag;
	function createJSDocProtectedTag(tagName:Null<Identifier>, ?comment:String):JSDocProtectedTag;
	function updateJSDocProtectedTag(node:JSDocProtectedTag, tagName:Null<Identifier>, comment:Null<String>):JSDocProtectedTag;
	function createJSDocReadonlyTag(tagName:Null<Identifier>, ?comment:String):JSDocReadonlyTag;
	function updateJSDocReadonlyTag(node:JSDocReadonlyTag, tagName:Null<Identifier>, comment:Null<String>):JSDocReadonlyTag;
	function createJSDocUnknownTag(tagName:Identifier, ?comment:String):JSDocUnknownTag;
	function updateJSDocUnknownTag(node:JSDocUnknownTag, tagName:Identifier, comment:Null<String>):JSDocUnknownTag;
	function createJSDocDeprecatedTag(tagName:Identifier, ?comment:String):JSDocDeprecatedTag;
	function updateJSDocDeprecatedTag(node:JSDocDeprecatedTag, tagName:Identifier, ?comment:String):JSDocDeprecatedTag;
	function createJSDocComment(?comment:String, ?tags:haxe.ds.ReadOnlyArray<JSDocTag>):JSDoc;
	function updateJSDocComment(node:JSDoc, comment:Null<String>, tags:Null<haxe.ds.ReadOnlyArray<JSDocTag>>):JSDoc;
	function createJsxElement(openingElement:JsxOpeningElement, children:haxe.ds.ReadOnlyArray<JsxChild>, closingElement:JsxClosingElement):JsxElement;
	function updateJsxElement(node:JsxElement, openingElement:JsxOpeningElement, children:haxe.ds.ReadOnlyArray<JsxChild>, closingElement:JsxClosingElement):JsxElement;
	function createJsxSelfClosingElement(tagName:JsxTagNameExpression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, attributes:JsxAttributes):JsxSelfClosingElement;
	function updateJsxSelfClosingElement(node:JsxSelfClosingElement, tagName:JsxTagNameExpression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, attributes:JsxAttributes):JsxSelfClosingElement;
	function createJsxOpeningElement(tagName:JsxTagNameExpression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, attributes:JsxAttributes):JsxOpeningElement;
	function updateJsxOpeningElement(node:JsxOpeningElement, tagName:JsxTagNameExpression, typeArguments:Null<haxe.ds.ReadOnlyArray<TypeNode>>, attributes:JsxAttributes):JsxOpeningElement;
	function createJsxClosingElement(tagName:JsxTagNameExpression):JsxClosingElement;
	function updateJsxClosingElement(node:JsxClosingElement, tagName:JsxTagNameExpression):JsxClosingElement;
	function createJsxFragment(openingFragment:JsxOpeningFragment, children:haxe.ds.ReadOnlyArray<JsxChild>, closingFragment:JsxClosingFragment):JsxFragment;
	function createJsxText(text:String, ?containsOnlyTriviaWhiteSpaces:Bool):JsxText;
	function updateJsxText(node:JsxText, text:String, ?containsOnlyTriviaWhiteSpaces:Bool):JsxText;
	function createJsxOpeningFragment():JsxOpeningFragment;
	function createJsxJsxClosingFragment():JsxClosingFragment;
	function updateJsxFragment(node:JsxFragment, openingFragment:JsxOpeningFragment, children:haxe.ds.ReadOnlyArray<JsxChild>, closingFragment:JsxClosingFragment):JsxFragment;
	function createJsxAttribute(name:Identifier, initializer:Null<ts.AnyOf2<StringLiteral, JsxExpression>>):JsxAttribute;
	function updateJsxAttribute(node:JsxAttribute, name:Identifier, initializer:Null<ts.AnyOf2<StringLiteral, JsxExpression>>):JsxAttribute;
	function createJsxAttributes(properties:haxe.ds.ReadOnlyArray<JsxAttributeLike>):JsxAttributes;
	function updateJsxAttributes(node:JsxAttributes, properties:haxe.ds.ReadOnlyArray<JsxAttributeLike>):JsxAttributes;
	function createJsxSpreadAttribute(expression:Expression):JsxSpreadAttribute;
	function updateJsxSpreadAttribute(node:JsxSpreadAttribute, expression:Expression):JsxSpreadAttribute;
	function createJsxExpression(dotDotDotToken:Null<DotDotDotToken>, expression:Null<Expression>):JsxExpression;
	function updateJsxExpression(node:JsxExpression, expression:Null<Expression>):JsxExpression;
	function createCaseClause(expression:Expression, statements:haxe.ds.ReadOnlyArray<Statement>):CaseClause;
	function updateCaseClause(node:CaseClause, expression:Expression, statements:haxe.ds.ReadOnlyArray<Statement>):CaseClause;
	function createDefaultClause(statements:haxe.ds.ReadOnlyArray<Statement>):DefaultClause;
	function updateDefaultClause(node:DefaultClause, statements:haxe.ds.ReadOnlyArray<Statement>):DefaultClause;
	function createHeritageClause(token:Int, types:haxe.ds.ReadOnlyArray<ExpressionWithTypeArguments>):HeritageClause;
	function updateHeritageClause(node:HeritageClause, types:haxe.ds.ReadOnlyArray<ExpressionWithTypeArguments>):HeritageClause;
	function createCatchClause(variableDeclaration:Null<ts.AnyOf2<String, VariableDeclaration>>, block:Block):CatchClause;
	function updateCatchClause(node:CatchClause, variableDeclaration:Null<VariableDeclaration>, block:Block):CatchClause;
	function createPropertyAssignment(name:ts.AnyOf6<String, Identifier, PrivateIdentifier, StringLiteral, NumericLiteral, ComputedPropertyName>, initializer:Expression):PropertyAssignment;
	function updatePropertyAssignment(node:PropertyAssignment, name:PropertyName, initializer:Expression):PropertyAssignment;
	function createShorthandPropertyAssignment(name:ts.AnyOf2<String, Identifier>, ?objectAssignmentInitializer:Expression):ShorthandPropertyAssignment;
	function updateShorthandPropertyAssignment(node:ShorthandPropertyAssignment, name:Identifier, objectAssignmentInitializer:Null<Expression>):ShorthandPropertyAssignment;
	function createSpreadAssignment(expression:Expression):SpreadAssignment;
	function updateSpreadAssignment(node:SpreadAssignment, expression:Expression):SpreadAssignment;
	function createEnumMember(name:ts.AnyOf6<String, Identifier, PrivateIdentifier, StringLiteral, NumericLiteral, ComputedPropertyName>, ?initializer:Expression):EnumMember;
	function updateEnumMember(node:EnumMember, name:PropertyName, initializer:Null<Expression>):EnumMember;
	function createSourceFile(statements:haxe.ds.ReadOnlyArray<Statement>, endOfFileToken:EndOfFileToken, flags:NodeFlags):SourceFile;
	function updateSourceFile(node:SourceFile, statements:haxe.ds.ReadOnlyArray<Statement>, ?isDeclarationFile:Bool, ?referencedFiles:haxe.ds.ReadOnlyArray<FileReference>, ?typeReferences:haxe.ds.ReadOnlyArray<FileReference>, ?hasNoDefaultLib:Bool, ?libReferences:haxe.ds.ReadOnlyArray<FileReference>):SourceFile;
	function createNotEmittedStatement(original:Node):NotEmittedStatement;
	function createPartiallyEmittedExpression(expression:Expression, ?original:Node):PartiallyEmittedExpression;
	function updatePartiallyEmittedExpression(node:PartiallyEmittedExpression, expression:Expression):PartiallyEmittedExpression;
	function createCommaListExpression(elements:haxe.ds.ReadOnlyArray<Expression>):CommaListExpression;
	function updateCommaListExpression(node:CommaListExpression, elements:haxe.ds.ReadOnlyArray<Expression>):CommaListExpression;
	function createBundle(sourceFiles:haxe.ds.ReadOnlyArray<SourceFile>, ?prepends:haxe.ds.ReadOnlyArray<ts.AnyOf2<InputFiles, UnparsedSource>>):Bundle;
	function updateBundle(node:Bundle, sourceFiles:haxe.ds.ReadOnlyArray<SourceFile>, ?prepends:haxe.ds.ReadOnlyArray<ts.AnyOf2<InputFiles, UnparsedSource>>):Bundle;
	function createComma(left:Expression, right:Expression):BinaryExpression;
	@:overload(function(left:Expression, right:Expression):AssignmentExpression<EqualsToken> { })
	function createAssignment(left:AssignmentPattern, right:Expression):DestructuringAssignment;
	function createLogicalOr(left:Expression, right:Expression):BinaryExpression;
	function createLogicalAnd(left:Expression, right:Expression):BinaryExpression;
	function createBitwiseOr(left:Expression, right:Expression):BinaryExpression;
	function createBitwiseXor(left:Expression, right:Expression):BinaryExpression;
	function createBitwiseAnd(left:Expression, right:Expression):BinaryExpression;
	function createStrictEquality(left:Expression, right:Expression):BinaryExpression;
	function createStrictInequality(left:Expression, right:Expression):BinaryExpression;
	function createEquality(left:Expression, right:Expression):BinaryExpression;
	function createInequality(left:Expression, right:Expression):BinaryExpression;
	function createLessThan(left:Expression, right:Expression):BinaryExpression;
	function createLessThanEquals(left:Expression, right:Expression):BinaryExpression;
	function createGreaterThan(left:Expression, right:Expression):BinaryExpression;
	function createGreaterThanEquals(left:Expression, right:Expression):BinaryExpression;
	function createLeftShift(left:Expression, right:Expression):BinaryExpression;
	function createRightShift(left:Expression, right:Expression):BinaryExpression;
	function createUnsignedRightShift(left:Expression, right:Expression):BinaryExpression;
	function createAdd(left:Expression, right:Expression):BinaryExpression;
	function createSubtract(left:Expression, right:Expression):BinaryExpression;
	function createMultiply(left:Expression, right:Expression):BinaryExpression;
	function createDivide(left:Expression, right:Expression):BinaryExpression;
	function createModulo(left:Expression, right:Expression):BinaryExpression;
	function createExponent(left:Expression, right:Expression):BinaryExpression;
	function createPrefixPlus(operand:Expression):PrefixUnaryExpression;
	function createPrefixMinus(operand:Expression):PrefixUnaryExpression;
	function createPrefixIncrement(operand:Expression):PrefixUnaryExpression;
	function createPrefixDecrement(operand:Expression):PrefixUnaryExpression;
	function createBitwiseNot(operand:Expression):PrefixUnaryExpression;
	function createLogicalNot(operand:Expression):PrefixUnaryExpression;
	function createPostfixIncrement(operand:Expression):PostfixUnaryExpression;
	function createPostfixDecrement(operand:Expression):PostfixUnaryExpression;
	@:overload(function(statements:haxe.ds.ReadOnlyArray<Statement>, param:ParameterDeclaration, paramValue:Expression):CallExpression { })
	function createImmediatelyInvokedFunctionExpression(statements:haxe.ds.ReadOnlyArray<Statement>):CallExpression;
	@:overload(function(statements:haxe.ds.ReadOnlyArray<Statement>, param:ParameterDeclaration, paramValue:Expression):CallExpression { })
	function createImmediatelyInvokedArrowFunction(statements:haxe.ds.ReadOnlyArray<Statement>):CallExpression;
	function createVoidZero():VoidExpression;
	function createExportDefault(expression:Expression):ExportAssignment;
	function createExternalModuleExport(exportName:Identifier):ExportDeclaration;
	function restoreOuterExpressions(outerExpression:Null<Expression>, innerExpression:Expression, ?kinds:OuterExpressionKinds):Expression;
};